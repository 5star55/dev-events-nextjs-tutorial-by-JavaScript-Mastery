import mongoose, { Schema, type HydratedDocument, type Model } from "mongoose"
import { EventModel } from "./event.model"

export interface Booking {
  /** Reference to the booked Event document. */
  eventId: mongoose.Types.ObjectId

  /** Booking contact email. */
  email: string

  /** Auto-generated by `timestamps: true`. */
  createdAt: Date
  /** Auto-generated by `timestamps: true`. */
  updatedAt: Date
}

const BookingSchema = new Schema<Booking>(
  {
    "eventId": {
      type: Schema.Types.ObjectId,
      ref: "Event",
      required: true,
    },

    "email": {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
      // Reject empty or improperly formatted email addresses.
      validate: [
        {
          validator: (value: string) => value.trim().length > 0,
          message: "email cannot be empty",
        },
        {
          validator: (value: string) => /^\S+@\S+\.\S+$/.test(value.trim()),
          message: "email must be a valid email address",
        },
      ],
    },
  },
  {
    // Automatically adds `createdAt` and `updatedAt` as Date fields.
    timestamps: true,
  }
)

// Index eventId for faster lookups like: find({ eventId })
BookingSchema.index({ eventId: 1 })

// Ensure one booking per email per event (prevents duplicates like same email booking same event twice).
BookingSchema.index({ eventId: 1, email: 1 }, { unique: true })

/**
 * Pre-save validation: ensure the referenced event exists.
 *
 * This prevents storing bookings that point to a non-existent Event.
 */
BookingSchema.pre("save", async function (this: HydratedDocument<Booking>) {
  const exists = await EventModel.exists({ _id: this.eventId })
  if (!exists) {
    throw new Error("Event does not exist for the provided eventId")
  }
})

export const BookingModel =
  (mongoose.models.Booking as Model<Booking> | undefined) ??
  mongoose.model<Booking>("Booking", BookingSchema)
