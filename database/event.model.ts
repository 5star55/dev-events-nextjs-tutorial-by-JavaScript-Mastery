import mongoose, { Schema, type HydratedDocument, type Model } from "mongoose"
import { randomBytes } from "crypto"

/**
 * Small, dependency-free slugifier (lowercase, dash-separated).
 * Used to generate a URL-friendly `slug` from the Event title.
 */
function slugify(value: string): string {
  return value
    .toLowerCase()
    .trim()
    .replace(/['"]/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
}

/**
 * Required string + validation that the value is non-empty after trimming.
 * This prevents saving empty strings like "   ".
 */
function requiredNonEmptyString(fieldName: string) {
  return {
    type: String,
    required: true,
    trim: true,
    validate: {
      validator: (value: string) => value.trim().length > 0,
      message: `${fieldName} cannot be empty`,
    },
  }
}

export interface Event {
  title: string
  slug: string
  description: string
  overview: string
  image: string

  venue: string
  location: string

  /**
   * Keep these as consistently-formatted strings for UI display.
   * Prefer ISO-like values: date = "YYYY-MM-DD" and time = "HH:mm".
   */
  date: string
  time: string

  mode: string
  audience: string
  agenda: string
  organizer: string
  tags: string[]

  /** Auto-generated by `timestamps: true`. */
  createdAt: Date
  /** Auto-generated by `timestamps: true`. */
  updatedAt: Date
}

const EventSchema = new Schema<Event>(
  {
    "title": requiredNonEmptyString("title"),

    // URL-friendly identifier derived from `title`.
    "slug": {
      type: String,
      required: true,
      index: true,
      validate: {
        validator: (value: string) => value.trim().length > 0,
        message: "slug cannot be empty",
      },
    },

    "description": requiredNonEmptyString("description"),
    "overview": requiredNonEmptyString("overview"),
    "image": requiredNonEmptyString("image"),

    "venue": requiredNonEmptyString("venue"),
    "location": requiredNonEmptyString("location"),
    "date": requiredNonEmptyString("date"),
    "time": requiredNonEmptyString("time"),

    "mode": requiredNonEmptyString("mode"),
    "audience": requiredNonEmptyString("audience"),
    "agenda": requiredNonEmptyString("agenda"),
    "organizer": requiredNonEmptyString("organizer"),

    "tags": {
      type: [String],
      required: true,
      validate: {
        validator: (value: string[]) =>
          Array.isArray(value) && value.length > 0 && value.every((t) => t.trim().length > 0),
        message: "tags must be a non-empty array of non-empty strings",
      },
    },
  },
  {
    // Automatically adds `createdAt` and `updatedAt` as Date fields.
    timestamps: true,
  }
)

// Unique index for the slug (the database is the final authority).
EventSchema.index({ slug: 1 }, { unique: true })

/**
 * Slug generation and validation.
 *
 * - `pre('validate')` ensures `slug` exists even though it's required.
 * - Only regenerates when the title changes (or on initial create).
 */
EventSchema.pre("validate", function (this: HydratedDocument<Event>) {
  if (!this.isNew && !this.isModified("title")) return
  this.slug = slugify(this.title)
})

/**
 * Pre-save hook (required): generate the slug from the title, and reduce collisions by
 * appending a short random suffix if the base slug is already taken.
 */
EventSchema.pre("save", async function (this: HydratedDocument<Event>) {
  if (!this.isNew && !this.isModified("title")) return

  const baseSlug = slugify(this.title)
  let nextSlug = baseSlug

  const EventModel = this.constructor as Model<Event>

  for (let attempt = 0; attempt < 5; attempt++) {
    const exists = await EventModel.exists({ slug: nextSlug, _id: { $ne: this._id } })
    if (!exists) break
    nextSlug = `${baseSlug}-${randomBytes(4).toString("hex")}`
  }

  this.slug = nextSlug
})

export const EventModel =
  (mongoose.models.Event as Model<Event> | undefined) ??
  mongoose.model<Event>("Event", EventSchema)
